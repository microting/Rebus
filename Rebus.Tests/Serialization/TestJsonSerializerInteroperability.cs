using System;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using NUnit.Framework;
using Rebus.Messages;
using Rebus.Serialization;
using Rebus.Serialization.Json;
using Rebus.Tests.Contracts;
using Rebus.Tests.Extensions;
using JsonSerializer = Rebus.Serialization.Json.JsonSerializer;
// ReSharper disable UnusedType.Local
// ReSharper disable ClassNeverInstantiated.Local

// ReSharper disable ArgumentsStyleStringLiteral
// ReSharper disable RedundantExplicitTupleComponentName
// ReSharper disable NotAccessedPositionalProperty.Local
// ReSharper disable ArgumentsStyleLiteral

namespace Rebus.Tests.Serialization;

[TestFixture]
public class TestJsonSerializerInteroperability : FixtureBase
{
    JsonSerializer _newtonsoft;
    SystemTextJsonSerializer _microsoft;

    protected override void SetUp()
    {
        var nameConvention = new SimpleAssemblyQualifiedMessageTypeNameConvention();

        _newtonsoft = new JsonSerializer(nameConvention);
        _microsoft = new SystemTextJsonSerializer(nameConvention, new JsonSerializerOptions
        {
            AllowTrailingCommas = true,
            PropertyNameCaseInsensitive = true,
            ReadCommentHandling = JsonCommentHandling.Skip,
        });
    }

    [TestCaseSource(nameof(GetSpecimens))]
    public async Task FromNewtonsoftToMicrosoft(object original)
    {
        var result = await Roundtrip(original, _newtonsoft, _microsoft);

        Assert.That(result.ToJson(), Is.EqualTo(original.ToJson()));
    }

    [TestCaseSource(nameof(GetSpecimens))]
    public async Task FromMicrosoftToNewtonsoft(object original)
    {
        var result = await Roundtrip(original, _microsoft, _newtonsoft);

        Assert.That(result.ToJson(), Is.EqualTo(original.ToJson()));
    }

    static IEnumerable<object> GetSpecimens()
    {
        yield return new SimpleStringMessage(Text: "Hello my friend 🙂");

        yield return new MessageWithDifferentTypes(
            String: "This is a string",
            Int: 23,
            Double: 78.4,
            Decimal: 23.5m,
            DateTime: new DateTime(1979, 3, 19),
            DateTimeOffset: new DateTimeOffset(2022, 02, 04, 12, 04, 00, TimeSpan.FromHours(1)),
            TimeSpan: TimeSpan.FromHours(2),
            SomeEnum: SomeEnum.TheValue
        );

        // this one cannot be roundtripped, because it contains a collection, which Newtonsoft JSON.NET serializes to an object with $type and $values fields
        //yield return new ComplexMessage("This is actually a bag of humanoids", new ComplexObject[]
        //{
        //    new(Name: "Møwns", Age: 42, Height: 181.5m, Properties: new Dictionary<string, string> {["Pockets"] = "full of stouts"}),
        //    new(Name: "Mørie", Age: 40, Height: 153.5m, Properties: new Dictionary<string, string> {["Beautiful"] = "indeed", ["Smart"] = "also"}),
        //});
    }

    record SimpleStringMessage(string Text);

    record MessageWithDifferentTypes(
        string String,
        int Int,
        double Double,
        decimal Decimal,
        DateTime DateTime,
        DateTimeOffset DateTimeOffset,
        TimeSpan TimeSpan,
        SomeEnum SomeEnum
    );

    enum SomeEnum { TheValue = 4 }

    record ComplexObject(string Name, int Age, decimal Height, IReadOnlyDictionary<string, string> Properties);
    record ComplexMessage(string Label, ComplexObject[] Objects);

    static async Task<object> Roundtrip(object original, ISerializer serializer, ISerializer deserializer)
    {
        var transportMessage = await serializer.Serialize(new Message(new Dictionary<string, string>(), original));

        Console.WriteLine($@"JSON generated by {serializer.GetType().Name}: 

{Encoding.UTF8.GetString(transportMessage.Body).PrettifyJson()}
");


        var message = await deserializer.Deserialize(transportMessage);

        return message.Body;
    }
}